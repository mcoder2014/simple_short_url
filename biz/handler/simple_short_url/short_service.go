// Code generated by hertz generator.

package simple_short_url

import (
	"context"
	"fmt"

	"github.com/cloudwego/hertz/pkg/app"
	"github.com/cloudwego/hertz/pkg/common/hlog"
	"github.com/cloudwego/hertz/pkg/protocol/consts"
	"github.com/mcoder2014/simple_short_url/biz/config"
	"github.com/mcoder2014/simple_short_url/biz/domain/service"
	"github.com/mcoder2014/simple_short_url/biz/model/simple_short_url"
	"github.com/mcoder2014/simple_short_url/util"
)

var defaultShortService *service.ShortService

func Init() error {
	s, err := service.NewShortService()
	if err != nil {
		return err
	}
	defaultShortService = s
	return nil
}

// RedirectShortURL .
// @router /:url [GET]
func RedirectShortURL(ctx context.Context, c *app.RequestContext) {
	var err error
	var req simple_short_url.RedirectShortURLRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	hlog.CtxInfof(ctx, "short=%v", req.GetURL())
	long, err := defaultShortService.GetShortUrl(ctx, req.GetURL())
	if err != nil {
		c.JSON(consts.StatusNotFound, &simple_short_url.RedirectShortURLResponse{
			BaseResp: &simple_short_url.BaseResp{
				StatusMessage: err.Error(),
			},
		})
	}
	if long == nil {
		c.JSON(consts.StatusNotFound, &simple_short_url.RedirectShortURLResponse{
			BaseResp: &simple_short_url.BaseResp{
				StatusMessage: "record not found",
			},
		})
		return
	}
	c.Redirect(consts.StatusTemporaryRedirect, []byte(*long))
}

// AddShortURL .
// @router /s/short_url [POST]
func AddShortURL(ctx context.Context, c *app.RequestContext) {
	var err error
	var req simple_short_url.AddShortURLRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	if err = CheckToken(req.GetToken()); err != nil {
		c.JSON(consts.StatusBadRequest, &simple_short_url.AddShortURLResponse{BaseResp: &simple_short_url.BaseResp{StatusMessage: err.Error()}})
		return
	}

	var short = req.GetShort()
	if req.GetShort() == "" {
		const defaultLength = 8
		short = util.GenerateRandomString(defaultLength)
	}

	cfg, err := defaultShortService.AddConfig(ctx, short, req.GetRedirectURL(), req.GetDesp(), req.GetToken())
	if err != nil {
		hlog.CtxWarnf(ctx, "add short url=%v failed, err=%v", req.Short, err)
		c.JSON(consts.StatusBadRequest, &simple_short_url.AddShortURLResponse{BaseResp: &simple_short_url.BaseResp{StatusMessage: err.Error()}})
	}
	hlog.CtxInfof(ctx, "add short url success, short=%v long=%v", cfg.Short, cfg.Long)

	resp := new(simple_short_url.AddShortURLResponse)
	resp.Short = config.GetConfig().BaseURL + "/s/" + short
	resp.Code = short
	resp.RedirectURL = cfg.Long
	c.JSON(consts.StatusOK, resp)
}

// DeleteShortURL .
// @router /s/:url [DELETE]
func DeleteShortURL(ctx context.Context, c *app.RequestContext) {
	var err error
	var req simple_short_url.DeleteShortURLRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	if err = CheckToken(req.GetToken()); err != nil {
		c.JSON(consts.StatusBadRequest, &simple_short_url.AddShortURLResponse{BaseResp: &simple_short_url.BaseResp{StatusMessage: err.Error()}})
		return
	}

	err = defaultShortService.DeleteConfig(ctx, req.GetShort())
	if err != nil {
		c.JSON(consts.StatusBadRequest, &simple_short_url.AddShortURLResponse{BaseResp: &simple_short_url.BaseResp{StatusMessage: err.Error()}})
		return
	}

	resp := new(simple_short_url.DeleteShortURLResponse)
	resp.BaseResp = &simple_short_url.BaseResp{StatusMessage: "success"}
	c.JSON(consts.StatusOK, resp)
}

// Refresh .
// @router /s/refresh [POST]
func Refresh(ctx context.Context, c *app.RequestContext) {
	var err error
	var req simple_short_url.RefreshRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}

	if err = CheckToken(req.GetToken()); err != nil {
		c.JSON(consts.StatusBadRequest, &simple_short_url.AddShortURLResponse{BaseResp: &simple_short_url.BaseResp{StatusMessage: err.Error()}})
		return
	}

	err = defaultShortService.Refresh(ctx)
	if err != nil {
		hlog.CtxWarnf(ctx, "refresh short url failed, err=%v", err)
	}
	resp := new(simple_short_url.RefreshResponse)
	c.JSON(consts.StatusOK, resp)
}

// ListShortURL .
// @router /s/list [GET]
func ListShortURL(ctx context.Context, c *app.RequestContext) {
	var err error
	var req simple_short_url.ListShortURLRequest
	err = c.BindAndValidate(&req)
	if err != nil {
		c.String(consts.StatusBadRequest, err.Error())
		return
	}
	if err = CheckToken(req.GetToken()); err != nil {
		c.JSON(consts.StatusBadRequest, &simple_short_url.AddShortURLResponse{BaseResp: &simple_short_url.BaseResp{StatusMessage: err.Error()}})
		return
	}

	configs, hasMore, err := defaultShortService.ListConfig(ctx, int(req.Offset), int(req.Limit))
	if err != nil {
		c.JSON(consts.StatusBadRequest, &simple_short_url.AddShortURLResponse{BaseResp: &simple_short_url.BaseResp{StatusMessage: err.Error()}})
	}
	resp := new(simple_short_url.ListShortURLResponse)

	var res []*simple_short_url.ShortURL
	for _, c := range configs {
		res = append(res, &simple_short_url.ShortURL{
			Short:      fmt.Sprintf("%s/s/%s", config.GetConfig().BaseURL, c.Short),
			Long:       c.Long,
			Desp:       c.Desp,
			Code:       c.Short,
			CreateTime: c.CreateTime,
		})
	}
	resp.ShortURLs = res
	resp.HasMore = hasMore
	c.JSON(consts.StatusOK, resp)
}
